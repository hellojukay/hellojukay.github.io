<!DOCTYPE html>
<html lang="en-us"><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
   <meta name="description" content="既然是常用的技巧，肯定是随时都能用，在各个 linux 发行版上都能用,都是最纯粹，最简单有效的技能。
网络 检查网络端口是否网络联通 curl {ip}:{port} -v 比如:
vagrant@archlinux _posts (master) $ curl 127.0.0.1:22 -v * Trying 127.0.0.1:22... * Connected to 127.0.0.1 (127.0.0.1) port 22 (#0) &gt; GET / HTTP/1.1 &gt; Host: 127.0.0.1:22 &gt; User-Agent: curl/7.74.0 &gt; Accept: */* &gt; * Received HTTP/0.9 when not allowed * Closing connection 0 curl: (1) Received HTTP/0.9 when not allowed 从输出日志可以看到 Connected 字样，说明端口是通的，类似的方式还有,netcat,telnet，不过这2个工具经常在服务器上没有。
获取 DNS 解析结果 通常我们使用 dig 或者 nslookup 命令来查看解析域名，但是这2个工具在很多场合下都没有，所以我们可以使用其它的工具来代替，比如: curl , ping">  

  <title>
    
      那些常用的linux小技巧
    
  </title>


  <link rel="shortcut icon" type="image/x-icon" href="/" />
  
  
  
  <link rel="stylesheet" href="/css/main.01273a70fa873b012d056499c16bb47955e0e7526c34edb73f05ca8f99f488ebc323423c6557f93f9b42a41de0448a25ce9a1ab577d0bf61e36eaf52a4979a1d.css" integrity="sha512-ASc6cPqHOwEtBWSZwWu0eVXg51JsNO23PwXKj5n0iOvDI0I8ZVf5P5tCpB3gRIolzpoatXfQv2Hjbq9SpJeaHQ==" />
  
</head>
<body a="auto">
        <main class="page-content" aria-label="Content">
            <div class="w">
<a href="/">..</a>


<article>
    <p class="post-meta">
        <time datetime="2020-12-29 00:00:00 &#43;0000 UTC">
            2020-12-29
        </time>
    </p>

    <h1>那些常用的linux小技巧</h1>

    

    <p>既然是常用的技巧，肯定是随时都能用，在各个 linux 发行版上都能用,都是最纯粹，最简单有效的技能。</p>
<h1 id="网络">网络</h1>
<h2 id="检查网络端口是否网络联通">检查网络端口是否网络联通</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>curl <span style="color:#f92672">{</span>ip<span style="color:#f92672">}</span>:<span style="color:#f92672">{</span>port<span style="color:#f92672">}</span> -v
</span></span></code></pre></div><p>比如:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>vagrant@archlinux _posts <span style="color:#f92672">(</span>master<span style="color:#f92672">)</span> $ curl 127.0.0.1:22 -v
</span></span><span style="display:flex;"><span>*   Trying 127.0.0.1:22...
</span></span><span style="display:flex;"><span>* Connected to 127.0.0.1 <span style="color:#f92672">(</span>127.0.0.1<span style="color:#f92672">)</span> port <span style="color:#ae81ff">22</span> <span style="color:#f92672">(</span><span style="color:#75715e">#0)</span>
</span></span><span style="display:flex;"><span>&gt; GET / HTTP/1.1
</span></span><span style="display:flex;"><span>&gt; Host: 127.0.0.1:22
</span></span><span style="display:flex;"><span>&gt; User-Agent: curl/7.74.0
</span></span><span style="display:flex;"><span>&gt; Accept: */*
</span></span><span style="display:flex;"><span>&gt;
</span></span><span style="display:flex;"><span>* Received HTTP/0.9 when not allowed
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>* Closing connection <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>curl: <span style="color:#f92672">(</span>1<span style="color:#f92672">)</span> Received HTTP/0.9 when not allowed
</span></span></code></pre></div><p>从输出日志可以看到 Connected 字样，说明端口是通的，类似的方式还有,netcat,telnet，不过这2个工具经常在服务器上没有。</p>
<h2 id="获取-dns-解析结果">获取 DNS 解析结果</h2>
<p>通常我们使用 dig 或者 nslookup 命令来查看解析域名，但是这2个工具在很多场合下都没有，所以我们可以使用其它的工具来代替，比如: curl , ping</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>vagrant@archlinux _posts <span style="color:#f92672">(</span>master<span style="color:#f92672">)</span> $ ping baidu.com
</span></span><span style="display:flex;"><span>PING baidu.com <span style="color:#f92672">(</span>39.156.69.79<span style="color:#f92672">)</span> 56<span style="color:#f92672">(</span>84<span style="color:#f92672">)</span> bytes of data.
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">64</span> bytes from 39.156.69.79 <span style="color:#f92672">(</span>39.156.69.79<span style="color:#f92672">)</span>: icmp_seq<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span> ttl<span style="color:#f92672">=</span><span style="color:#ae81ff">46</span> time<span style="color:#f92672">=</span>32.4 ms
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>vagrant@archlinux _posts <span style="color:#f92672">(</span>master<span style="color:#f92672">)</span> $ curl baidu.com -v
</span></span><span style="display:flex;"><span>*   Trying 220.181.38.148:80...
</span></span><span style="display:flex;"><span>* Connected to baidu.com <span style="color:#f92672">(</span>220.181.38.148<span style="color:#f92672">)</span> port <span style="color:#ae81ff">80</span> <span style="color:#f92672">(</span><span style="color:#75715e">#0)</span>
</span></span><span style="display:flex;"><span>&gt; GET / HTTP/1.1
</span></span><span style="display:flex;"><span>&gt; Host: baidu.com
</span></span><span style="display:flex;"><span>&gt; User-Agent: curl/7.74.0
</span></span><span style="display:flex;"><span>&gt; Accept: */*
</span></span><span style="display:flex;"><span>&gt;
</span></span></code></pre></div><p>甚至是 wget 命令</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>vagrant@archlinux _posts <span style="color:#f92672">(</span>master<span style="color:#f92672">)</span> $ wget google.com
</span></span><span style="display:flex;"><span>--2020-12-29 13:44:10--  http://google.com/
</span></span><span style="display:flex;"><span>Resolving google.com <span style="color:#f92672">(</span>google.com<span style="color:#f92672">)</span>... 46.82.174.69
</span></span><span style="display:flex;"><span>Connecting to google.com <span style="color:#f92672">(</span>google.com<span style="color:#f92672">)</span>|46.82.174.69|:80...
</span></span></code></pre></div><h2 id="网络代理">网络代理</h2>
<p>如果我们的服务器不能上网，但是内网中有其它的代理机器可以上网，我们也可以通过设置代理环境变量来上网比如</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>export https_proxy<span style="color:#f92672">=</span>http://<span style="color:#f92672">{</span>ip<span style="color:#f92672">}</span>:<span style="color:#f92672">{</span>port<span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>export http_proxy<span style="color:#f92672">=</span>http://<span style="color:#f92672">{</span>ip<span style="color:#f92672">}</span>:<span style="color:#f92672">{</span>port<span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>export no_proxy<span style="color:#f92672">=</span>host1,host2
</span></span></code></pre></div><p>注意最后一条，我们也可以通过设置 no_proxy 来跳过某些网址不要走代理（多个用逗号隔开),还要说明的是上面的环境变量全大写或者全小写都可以.  wget  命令也可以通过 -e 参数来设置代理的环境变量。</p>
<h2 id="网络认证">网络认证</h2>
<p>netrc 是中比较简单粗暴的网络认证方式，对于 wget , curl , git 都适用，基本用法就是在 $HOME 目录下面创建一个隐藏文件 .netrc 添加如下内容:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-txt" data-lang="txt"><span style="display:flex;"><span>machine {your host` login {username} password {your pass}
</span></span></code></pre></div><p>具体可以查看 wiki. curl 和 wget 也都还有命令设置认证的方式，具体可以参考: <a href="https://stackoverflow.com/questions/3044315/how-to-set-the-authorization-header-using-curl">https://stackoverflow.com/questions/3044315/how-to-set-the-authorization-header-using-curl</a></p>
<h1 id="文本文件">文本文件</h1>
<h2 id="文本搜索">文本搜索</h2>
<p>这方面的内容，我第一个要介绍的就是 grep 命令，他实在太强大了，常规的用法，我需要在一堆目录中搜索一个单词</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>grep <span style="color:#f92672">{</span>your keyworkd<span style="color:#f92672">}</span> -rn <span style="color:#f92672">{</span>foler<span style="color:#f92672">}</span>
</span></span></code></pre></div><p>这里 -r 是递归的意思, -n 是显示行号的意思，经常我遇到程序打印了我看不懂的一异常日志，我回拿着日志的关键信息到代码里面搜索，很快就能找到原因。当然关于 grep 的用法还有</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>grep -e <span style="color:#e6db74">&#34;aaaa|bbb&#34;</span> file  <span style="color:#75715e"># 根据正则搜索</span>
</span></span><span style="display:flex;"><span>grep -v <span style="color:#e6db74">&#34;aaa&#34;</span>            <span style="color:#75715e"># 排除搜索</span>
</span></span></code></pre></div><p>awk 也算是一个不错的文本搜索工具，他能从文本去取出你想要的列，默认情况是按照空格分开字符串，你可以使用 -F 选项来设置一个风格符号</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>awk -F <span style="color:#e6db74">`</span>a<span style="color:#e6db74">`</span> <span style="color:#75715e"># 使用字符 a 分割字符串</span>
</span></span></code></pre></div><p>从字符串中获取想要的列</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>awk <span style="color:#e6db74">&#39;{print $1}&#39;</span>
</span></span></code></pre></div><p>这里使用 $1 获取第一列，注意第一列是 $1 而不是 $0 , $0 代表当前字符串,一次想要获取后面其它列可以使用 $2 , $3 &hellip;, awk 还能使用 printf 函数来格式输出这里就不多介绍了。</p>
<h2 id="文本显示">文本显示</h2>
<p>strings 命令是一个不错的工具，大部分的 linux 都有这工具，它可以查看二进制文件中的字符串信息，对于二进制文件和文本文件都可以使用，所以你在也不用担心不小心对一个二进制文件使用 cat 后输出一堆乱码而手足无措。</p>
<h2 id="批量操作">批量操作</h2>
<p>一般我们选出出来的字符串，我们还会通过管道符来操作，比如获取本机器上的所有镜像名字，然后删除他们</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>docker image ls | awk <span style="color:#e6db74">&#39;{print $3`}&#39;</span> | xargs -I <span style="color:#f92672">{}</span> -P <span style="color:#ae81ff">4</span> docker rmi <span style="color:#f92672">{}</span>
</span></span></code></pre></div><p>这里我们就使用到了 xargs 这命令, -I 选项设置的我们的目标字符串用 {} 代理，后面的命令回自动拼接并且执行，使用 -P 设置最大并发数量。</p>

</article>

            </div>
        </main>
    </body></html>
